% !TeX root = ..\G16.tex
\section{Introduktion \& Problemanalyse}
\subsection{Forfatterskab}
En oversigt over hvilke gruppemedlemmer der har skrevet hvad i rapporten kan ses i \cref{sec:arbejde}.
\subsection{Opgaven}
I dette projekt er målet at udvikle et program der implementerer spillet ``Reversi''; et brætspil der handler om at vinde mest muligt terræn ved at indkapse og vende modstanderens brikker\footnote{\href{https://www.wikiwand.com/en/Reversi}{Reversi på Wikipedia}} Vi benytter os af regelsættet i projektoplægget, og jf. samme oplæg skrives den grafiske brugerflade med JavaFX.\newline
Med udgangspunkt i Model-Viewer-Controller konceptet (\emph{MVC}) skal der implementeres en klasse med den underliggende logik for spillet, en klasse der implementerer den grafiske brugerflade, og en klasse der binder disse sammen.
\subsection{Specifikationer}
Reversi er et relativt simpelt spil med få regler. Vi ved, at vi skal lavet et bræt med 8x8 felter. I begyndelsen af spillet skal der placeres 4 brikker af to forskellige farver, én farve pr. spiller. Herefter skal de to spillere placere deres brikker én efter én, og vende modstanderens brikker ved at klemme dem inde mellem ensfarvede brikker. Brikkerne kan kun stilles et sted, hvor man med sikkerhed klemmer en brik af modsat farve inde. Vinderen er den spiller, der har flest brikker på brættet, når alle 64 felter er udfyldt. Alternativt kan man vinde spillet, ved at modstanderen siger "pas" to ture i træk.
\begin{itemize}
    \item Begyndende spiller: Tildeles tilfældigt mellem de to spillere. Ved efterfølgende ture, skiftes spillerne.
    \item Startkonfiguration: Første spiller vælger to placeringer inden for de midterste fire felter. Næste spillers brikker optager resterende to felter og første spiller har næste træk.
    \item Placering af brikker: En brik må kun ligges på et tomt felt således at en eller flere af modstanderens brikker indkapsles mellem den lagte brik og en af spilleres andre brikker. Indkapslingen kan ske ad vertikale, horisontale og diagonale retninger.
    \item Vending af brikker: Ved placering af en brik vil alle modstanderens, i det øjeblik, indkapslede brikker mellem den lagte brik og spillerens egne brikker blive vendt.
    \item Spillets afslutning: Når brættet er fyldt eller begge spillere har meldt pas efter hinanden.
    \item Vinder: Den spiller som har flest brikker (og dermed vundet mest terræn) har vundet spillet.
    \item Spillet skal være indeholdt i et eksekverbart jar-arkiv som skal kunne køre på alle maskiner (selv uden at JavaFX er installeret på end-user maskinen).
\end{itemize}
Ud fra disse specifikationer bliver programmet udviklet. Der er artistisk frihed ift. brikkers og brættets farve, hvor stort brættet skal være ift. computerskærmen og hvordan layout'et skulle se ud mht. placering af eventuelle knapper og tekstområde ift. selve brættet. 
\subsection{Målsætninger}
Projektets primære mål er at udvikle et program der overholder specifikationerne ovenfor. Spillet har skulle kunne køre, og været testet adskillige gange for robusthed og eventuelle små fejl.\newline
Krav til brugerfladen er at letlæselighed, overskuelighed, og simpel struktur, uden unødvendig redundans. \newline
Programmets struktur skal ligeledes være simpelt og uden redundans, således at det er nemt at redigere i koden, for at implementerer ændringer undervejs, da dette kan blive en stor udfordring, skulle man have skrevet noget sammenfiltret og kompliceret\footnote{\href{https://www.wikiwand.com/en/Spaghetti_code}{Spaghettikode}}.\newline
Sekundære mål er at implementere så mange valgfri features som muligt, som vi dømte inde for vores faglige kapacitet. Igen hjælper det her med simpel og overskuelig kode, der gør, at man let kan genbruge noget, man tidligere har skrevet, til at udvide og forbedre programmet.\newline
Et andet vigtigt mål er at arbejde som en gruppe. Med det menes der at lære, hvorledes man arbejder sammen, dele arbejdet op når det kommer til et projekt af denne størrelse, og tage stilling til hvordan ens kode kan sammenflettes med de andre gruppemedlemmers kode.
\subsection{Tilgang til opgaveløsningen}
Projektet har budt på adskillige overvejelser ift. løsning af problemer. Som det første havde vi det visuelle, og dernæst havde vi det logiske. Vi blev enige om at dele arbejdet op i grupper af to og to. Så kunne vi spørge os selv: Hvordan vil vi gribe vores opgave an? Hvad angår den grafiske del, besluttede vi os for at bruge \emph{Scene Builder}\footnote{\href{https://gluonhq.com/products/scene-builder/}{Scene Builder}} til at lave vores \emph{Scene} og nogle af vores \emph{Nodes}. Fordelen her er at have al grafisk info stående på en let overskuelig måde og kun definere interaktionen i vores klasser. Ulempen vil dog være, at det vil tage længere tid at skrive hver enkelt ting op (specificere en knaps layout, størrelse mm). En anden fordel ved Scene Builder er, at det er hurtigt, overskueligt (inde i selve programmet), og det er let at forbinde evt. kode fra andre klasser med det, man har designet i programmet.\newline
Dog er det ikke alt, der ikke let kan løses i Scene Builder. Detaljer som actions og id på nodes er nemere at redigere direkte i \emph{FXML} filen efter layoutet er defineret i Scene Builder.\newline


% Følgende tekst høre til i diskussionsafsnittet:
% Et problem, der fyldte en del, var hvordan vi skulle bære os ad med at placere en cirkel med et museklik, således at den befinder sig i midten af et felt i vores gridpane. Her måtte vi teste med mange løsninger. Vores fejl var den, at vi fokuserede på cirklens koordinater ift. gridpane't. Vi startede ud med at skrive cirklens koordinater modulus 2. Dette resulterede i, at cirklen blev placeret i hjørnet af et pane, således at den lå over fire forskellige panes. Efter nogle forsøg med at dividere og andre ting, kom vi frem til, at vi ganske enkelt bare skulle placere cirklen på den pågældende pane's længde og bredde, divideret med to. Dette løste vores problem.