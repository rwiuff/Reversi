% !TeX root = ..\G16.tex
\section{Konklusion}

\subsection{Vores mål}\label{VM}
Vi satte os til mål at skulle skrive programmet Reversi i sin mest basale form. Dette opnåede vi, og dermed opfyldte vi vores minimums-krav. Dernæst satte vi for os selv, at vi ville lave så mange avancerede tilføjelser til programmet som muligt. Vi nåede at tilføje flere udvidelser, som forbedrede spillerens brugeroplevelse, hvilket var en sejr, men der var også forsøg på udvidelser, hvor vi måtte se os slået. Se næste {vores mangler} for yderligere info. 
Vores kode endte med at være let overskueligt og struktureret. Vi var i stand til at implementere flere udvidelser, enten via. genbrug af kode fra den basale kildekode, eller ved indsættelse af ny kode enkelte steder, uden at forpurre systemet. Ofte kunne vi ganske enkelt oprette en metode, og så kalde den de steder, hvor det var relevant. 
Vi lærte også at arbejde som en gruppe inden for software/programmerings-feltet. De fleste af os var nye til brugen af "Git-Hub", men takket være Rasmus' erfaring og kyndighed med programmet, lærte vi hurtigt hvordan vi kunne arbejde sammen, dele kode, push'e, pull'e, og skabe nye grene, hvorpå vi kunne arbejde på vores udvidelser i fred, uden nogen uventede ændringer i koden. 


\subsection{Vores mangler}
\subsubsection{SpeedReversi}\label{SR}
En pointe fremhævet i den avancerede del af Yahya, er, at give spillere mulighed for at spille med en timer.
\begin{itemize}
\item Timeren er en vigtig del af de fleste strategispil (spil, der kræver en vis forhånds- planlægning til næste træk), fordi timeren øver spillernes tænkehastighed og tvinger dem til at tænke hurtigere og træffe beslutninger for næste træk under pres, hvilket kan føre til at man træffer en forkert beslutning, eller at man løber tør for tid. Denne tilføjelse til denne type spil gør spillet sjovere for nogle. 
\end{itemize}

I gruppen aftalte vi at Yahya starter med at implementere timer-metoden ind i vores standard logik og får den til at køre direkte, når spillet starter. Derefter vil vi så tilføje en Bottom til ”menu.fxml” kaldet: ” Speed-Reversi ”, der finder plads under ”BeginGame” (normal game).
På den måde adskiller vi ”SpeedMode”, så det bliver et ekstra valg hvis man ønsker det. 
Timer-Metoden tog ca. 2 dage at implementere, for der har været nogle udfordringer undervejs så som: 
\begin{itemize}

\item Der blev brugt "Thread" til at manipulere timeren med spillet, men fejlen var at ved brug af "Thread.sleep" vil det tage programmet et sekund at kører metoden igennem. Det har vi oplevet, da vi har prøvet at spille hurtigt; så vil timeren ikke begynde på at tælle ned, for den har brug for et sekund til at tænke. 
\item Som et forsøg på at løse fejlen, har vi prøvet at forkorte rundturstiden for "Thread.sleep" ved at bruge "System.nanoTime" hvor man kan regne tiden, som metoden bruger i nanoTime, og trække det fra. Det hjalp ikke; fejlen var det samme. 
\item Et andet forsøg, var ved at prøve "Animationtimer" men vi kunne ikke få metoden til at ændre timeren fra spiller 1 til spiller 2. 
 i 
\item Løsning: 
Der blev brugt "TimeLine" hvor den virkede fint med både "turnsskift"-hastighed mellem spillerne og reagerer med "getturn()". 
\end{itemize}
\subsubsection{Flette Reversi-Timer}\label{FRT}
Nogle af de største udfordringer vi har haft med SpeedMode er, at kombinere metoden ind og få den til at køre adskilt, dvs. kun når man vælger at spille med SpeedMode, som vi har lavet en knap til i "Menu.FXML" og en "BorderPane" i "Main.FXML".
\subsubsection{Metodeimplementering}\label{MI}
\begin{itemize}
\item Efter oprettelsen af "ReversiTimer"-klassen, som indholder Timer-metoden, har Yahya tænkt sig at oprette en anden Controller-klasse for ReversiTimeren, således at man kan kaldee den nye "controller1" når man trykker på knappen " SpeedReversi" ellers kaldes den nuværende "Controller".
På den måde vil vi nemt kunne flette Timer-logikken ind med standard logik uden væsentlige ændringer i koden, men der har været uenighed om det, for det kunne være et problem, hvis vi senere opdager nogle fejl eller hvis vi skal ændre på noget i hoved-Controller-klassen, for så bliver vi nødt til også at ændre det i Controller2-klassen. 
\item Derfor havde vi tænkt os at få Timeren ind ved at tilføje en "boolean" som sætter "SpeedMode=false;" og så begyndte vi at tilføje 
" if (speedMode == true) \{ " "else" til metoderne ( in(),restart(),onPaneClicked(),beginGame) og så satte vi 
"speedReversi(ActionEvent event) \{	
		speedMode = true; "
\item Vi var meget tætte på at få det hele til at køre, men udfordringer var stadig til stede. Vi mødte en fejl, der gør at enten kan timeren ses på begge "modes", ellers forsvinder den i begge Mode også, dvs. at der har været en sammenhæng mellem den normal logik og den ny med Timeren.
Efter en lang analyse af "if" og "else" sætninger fandt vi fejlen, som var bag 'Controller', da vi loadede "main.fxml" med standard Controller'en hver gang, derfor vil 'Value' af SpeedMode altid være "True". 

\item Løsning: 
implementere følgende i "speedReversi(ActionEvent event)":
\item kald metoderne fra "begingame()" med følgende tilføjelser 
" controller.setSpeedMode(true);
            controller.getReversiTimerpane().setVisible(true); " 

   sæt følgende metoder ind i "begingame"
   " controller.setSpeedMode(false);
        controller.getReversiTimerpane().setVisible(false); "

\item De opnåede rettelser var desværre i utide til at kunne flette ind i hovedprojektet, da vi fik at vide at sene ændringer kan kost dyrt. Derfor valgte vi at levere den bedste version, vi kunne nå, til den tid vi har. 
\end{itemize}








\subsubsection{Antal Mulige vendinger}\label{AMV}
Aslan forsøgte sig med en udvidelse til udvidelsen, der gjorde spillerne i stand til at se deres mulige træk. Idéen med udvidelsen var den, at man kunne ved at trykke på en knap, kunne se på de mulige træk, hvor mange brikker der vil blive vendt. Altså hvis man ved at sætte en brik på en mulig placering, vil vende 3 brikker, vil der stå tallet 3 i midten af den mulige placering. Problemet ved implementeringen opstod, da programmet skulle se fremad, fremfor bagud. Strategien var, at skabe en integer i board-klassen, kaldet "tilesFlipped". Hver gang metoden 'flip()' blev kaldt, skulle denne integer sættes lig 0, og jeg satte den til at inkrementere hver gang en brik blev vendt, således at man altid vil få det eksakte tal vendte brikker. Dernæst modificerede jeg 'showLegalMoves' til at vise 'tilesFlipped' i midten af cirklerne. Problemet var følgende: For det første, viste alle cirkler det samme tal. Derudover viste cirklerne altid hvor mange brikker der blev vendt SIDSTE runde. Målet var, at de skulle vise tallene en runde FREMAD. Forsøgene nåede deres ende, ikke på grund af fejl og exceptions, men ganske enkelt grundet en blokade. Jeg havde ingen anelse om, hvor jeg skulle implementere hvad. Nøglen lå i board-klassens 'validMoves', men grundet min manglende erfaring med hashmaps, som board-klassen i høj grad består af, så jeg mig nødsaget til at give op. 

\subsubsection{Lyd}\label{lyd}
Lyd er en af de andre avancerede funktioner, som Abinav forsøgte at implementere. Lyd ville forbedre brugeroplevelsen og hjælpe spillere med at fordybe sig i spillet, hvilket gør det til en fremragende funktion at inkludere. Efter hvert træk ville funktionen have ladet deltagerne vide, hvordan spillet forløb. Derudover ville det have givet spillerne feedback om, hvorvidt de havde placeret brikken korrekt på brættet. At inkludere lyd i spillet ville have mindsket behovet for, at spillere skulle læse teksten efter hvert træk, som f.eks. hvis de placerede brik på brættet.
Musikfilerne blev importeret ved hjælp af JavaFX-værktøjer som mediaPlayer og media. Fejl som "fil kan ikke findes", og "fil kan ikke indlæses", blev stødt på under adgang til mediefiler. Try-catch-sætninger blev brugt til at rette op på disse problemer. Hver lyd- eller mediefil havde en separat metode, der indeholdt funktionerne mediaPlayer.play(), mediaPlayer.stop() og mediaPlayer.stop(). De nævnte teknikker gjorde det muligt at afspille, pause og stoppe musikken. Det vigtigste problem, der opstod under integration af lydkomponenten, var at musikfilerne af og til, når programmet kørte, ville blive korrupte. Musikfilerne fungerede korrekt, når de blev afspillet ved hjælp af 'VCL' eller 'groove'-musik på computeren. Det var umuligt at afgøre, hvad der fik musikfilerne til at blive korrupte, da programmet kørte. Et andet problem, der udviklede sig, var lydens manglende evne til altid at spille som reaktion på brugerens aktivitet. Sagt på eDer var adskillige forsøg på at rette denne fejl, herunder at kontrollere, om handlingshændelsens kode kaldte den relevante lydfil, men ingen af dem lykkedes. Til sidst blev det besluttet ikke at tilføje funktionen lyd til Reversi, da de fejl, der blev opstået ved at tilføje funktionen, ikke var i stand til at rette og krævede et højt kendskab til javafx mediaplayer og medieklasse.


\subsection{Hvad har vi lært}
\subsubsection{Aslan}\label{HHVLA}
Dette projekt har bidraget meget til mit billede af, hvordan det er at arbejde inden for software/programmeringsfeltet. Jeg var i begyndelsen meget usikker på, hvordan man skulle arbejde som gruppe på ét projekt, da vi tidligere afleveringsopgaver ganske enkelt har delt de fire forskellige opgaver op imellem os. Jeg fandt dog hurtigt ud af, at systemet er det samme, og dog ikke. Man uddelegerer opgaver, men sparer også meget med hinanden, og kigger på tingene sammen. Man arbejder på at forbedre hinandens arbejde, så man i fællesskab kan komme frem til det bedst-mulige produkt. Derudover har dette forløb også bare været en god mulighed for at udvikle mine programmerings- og problemløsningskompetencer. Det har været fedt at kunne stå over for et problem, og have muligheden for at teste forskellige løsninger af døgnet rundt, frem for at skulle bekymre sig om andre fag. Jeg håber på flere forløb som dette i fremtiden, hvor vi alle er mere erfarne og kompetente programmører.  
\subsubsection{Yahya}\label{YY}





\subsubsection{Rasmus}

\subsubsection{Abinav}\label{AA}

