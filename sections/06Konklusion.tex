% !TeX root = ..\G16.tex
\section{Konklusion}

\subsection{Vores mål}\label{VM}
Vi satte os til mål at skulle skrive programmet Reversi i sin mest basale form. Dette opnåede vi, og dermed opfyldte vi vores minimums-krav. Dernæst satte vi for os selv, at vi ville lave så mange avancerede tilføjelser til programmet som muligt. Vi nåede at tilføje flere udvidelser, som forbedrede spillerens brugeroplevelse, hvilket var en sejr, men der var også forsøg på udvidelser, hvor vi måtte se os slået. Se næste {vores mangler} for yderligere info. 
Vores kode endte med at være let overskueligt og struktureret. Vi var i stand til at implementere flere udvidelser, enten via. genbrug af kode fra den basale kildekode, eller ved indsættelse af ny kode enkelte steder, uden at forpurre systemet. Ofte kunne vi ganske enkelt oprette en metode, og så kalde den de steder, hvor det var relevant. 
Vi lærte også at arbejde som en gruppe inden for software/programmerings-feltet. De fleste af os var nye til brugen af "Git-Hub", men takket være Rasmus' erfaring og kyndighed med programmet, lærte vi hurtigt hvordan vi kunne arbejde sammen, dele kode, push'e, pull'e, og skabe nye grene, hvorpå vi kunne arbejde på vores udvidelser i fred, uden nogen uventede ændringer i koden. 


\subsection{Vores mangler}
\subsubsection{SpeedReversi}\label{SR}
En pointe fremhævet i den avanceret del af Yahya, er, at give spillere mulighed for at spille med en timer.
\begin{itemize}
\item Timeren er en vigtig del af de fleste strategispil (spil, der kræver en vis forhånds planlægning til næste træk), fordi timeren øvre spillernes tænkehastighed og tvinger dem til at tænke hurtigere og træffe beslutninger for næste træk under pres, hvilket kan føre til, at man træffer en forkert beslutning eller man løber tør for tid. denne tilføjelse til denne type spil gør spillet sjovere for nogle. 
\end{itemize}

I gruppen aftalte vi om at Yahya starter med at implementerer timer metoden ind i vores standard logik og få den til at køre direkte når spillet starter, derefter vil vi så tilføj en Bottom til ” menu.fxml ” kaldes ” Speed-Reversi ”, der befinder plads under ”BeginGame” (normal game).
På den måde adskiller vi ”SpeedMode”, så den bliver en ekstra valg hvis man ønsker det. 
Timer-Metoden tog ca. 2 dag at implementerer, for der har været nogle udfordringer undervejs så som: 
\begin{itemize}

\item Der blev brugt "Thread" til manipulere timeren med spillet, men fejlen var at ved bruge af "Thread.sleep" vil det tage programmet et sekund at kører metoden igennem, det har vi oplevet da vi har prøvet at spille hurtigt, så vil timeren ikke begynd at tælle ned, for den har brug for et sekund at tænke. 
\item som et forsøge på at løse fejlen, har vi brugt at forkorte rundturstiden for "Thread.sleep" ved at brug " System.nanoTime" hvor man kan regne tiden som metoden bruger i nanoTime og træk det fra. Det hjalp ikke,fejlen var det samme. 
\item Et andet forsøge, var med at prøve "Animationtimer" men vi kunne ikke få metoden til at ændre timeren fra spiller 1 til spiller 2. 

\item Løsning: 
Der blev brugt "TimeLine" hvor den virkede fint med både turnsskifthastighed mellem spillerne og regering med "getturn()". 
\end{itemize}
\subsubsection{Flette Reversi Timer}\label{FRT}
Som nogle af de største udfordringer vi har haft med SpeedMode er, at kombinær metoden ind og få den til at køre adskillet, Dvs. kun når man vælge at spille med SpeedMode, som vi har lavet en knappe til i "Menu.FXML" og en "BorderPane" i "Main.FXML".
\subsubsection{Metode implementering}\label{MI}
\begin{itemize}
\item Efter oprettelsen af "ReversiTimer" klassen som indholder Timer metoden, har Yahya tænkte sig at oprette en anden Controller klasse for ReversiTimeren således at, man kan kald den ny "controller1" når man trykker på knappen " SpeedReversi" ellers kaldes den nuværende "Controller".
På den måde vil vi kunne nemt flette Timer logikken ind med Standard logik uden væsentlig ændringer i koden, men der har været uenighed om det,fordi det kunne være et problem hvis vi sanerer opdager nogle fejl eller hvis vi skal ændre på noget i hoved Controller klassen, for så bliver vi nødt til at ændre det også i Controller2 klassen. 
\item Derfor har vi tænkte os at få Timeren ind med at tilføje en "boolean" som sætter "SpeedMode=false;" og så begyndt vi at tilføj 
" if (speedMode == true) \{ " "else" til metoderne ( in(),restart(),onPaneClicked(),beginGame) og så har vi sat 
"speedReversi(ActionEvent event) \{	
		speedMode = true; "
\item Vi var meget tæt på at få det hele til at køre, men udfordringer var stadig til sted. Vi mødet en fejl der gør at enten timeren kan ses på begge Mode ellers forsvinder den i begge Mode også, dvs. at der har været en sammenhæng mellem den normal logik og den ny med Timeren.
Efter en lang analyse af "if" og "else" sætninger, fandt vi fejlen som l


\end{itemize}








\subsubsection{Antal Mulige vendinger}\label{AMV}
Aslan forsøgte sig med en udvidelse til udvidelsen, der gjorde spillerne i stand til at se deres mulige træk. Idéen med udvidelsen var den, at man kunne ved at trykke på en knap, kunne se på de mulige træk, hvor mange brikker der vil blive vendt. Altså hvis man ved at sætte en brik på en mulig placering, vil vende 3 brikker, vil der stå tallet 3 i midten af den mulige placering. Problemet ved implementeringen opstod, da programmet skulle se fremad, fremfor bagud. Strategien var, at skabe en integer i board-klassen, kaldet "tilesFlipped". Hver gang metoden 'flip()' blev kaldt, skulle denne integer sættes lig 0, og jeg satte den til at inkrementere hver gang en brik blev vendt, således at man altid vil få det eksakte tal vendte brikker. Dernæst modificerede jeg 'showLegalMoves' til at vise 'tilesFlipped' i midten af cirklerne. Problemet var følgende: For det første, viste alle cirkler det samme tal. Derudover viste cirklerne altid hvor mange brikker der blev vendt SIDSTE runde. Målet var, at de skulle vise tallene en runde FREMAD. Forsøgene nåede deres ende, ikke på grund af fejl og exceptions, men ganske enkelt grundet en blokade. Jeg havde ingen anelse om, hvor jeg skulle implementere hvad. Nøglen lå i board-klassens 'validMoves', men grundet min manglende erfaring med hashmaps, som board-klassen i høj grad består af, så jeg mig nødsaget til at give op. 

\subsubsection{Lyd}\label{lyd}
Lyd er en af de andre avancerede funktioner, som Abinav forsøgte at implementere. Lyd ville forbedre brugeroplevelsen og hjælpe spillere med at fordybe sig i spillet, hvilket gør det til en fremragende funktion at inkludere. Efter hvert træk ville funktionen have ladet deltagerne vide, hvordan spillet forløb. Derudover ville det have givet spillerne feedback om, hvorvidt de havde placeret brikken korrekt på brættet. At inkludere lyd i spillet ville have mindsket behovet for, at spillere skulle læse teksten efter hvert træk, eller mens de placerede brik på brættet.
Musikfilerne blev importeret ved hjælp af Java FX-værktøjer som mediaPlayer og media. Fejl som fil kan ikke findes, og fil kan ikke indlæses, blev stødt på under adgang til mediefiler. Try-catch-sætninger blev brugt til at rette op på disse problemer. Hver lyd- eller mediefil havde en separat metode, der indeholdt funktionerne mediaPlayer.play(), mediaPlayer.stop() og mediaPlayer.stop(). De nævnte teknikker gjorde det muligt at afspille, pause og stoppe musikken. Det vigtigste problem, der opstod under integration af lydkomponenten, var, at musikfilerne af og til, når programmet kørte, ville blive korrupte. Musikfilerne fungerede korrekt, når de blev afspillet ved hjælp af VCL eller groove-musik på computeren. Det var umuligt at afgøre, hvad der fik musikfilerne til at blive korrupte, da programmet kørte. Et andet problem, der udviklede sig, var lydens manglende evne til altid at spille som reaktion på brugerens aktivitet. Der var adskillige forsøg på at rette denne fejl, herunder at kontrollere, om handlingshændelsens kode kaldte den relevante lydfil, men ingen af dem lykkedes. Til sidst blev det besluttet ikke at tilføje funktionen lyd til Reversi, da de fejl, der blev opstået ved at tilføje funktionen, ikke var i stand til at rette og krævede et højt kendskab til java fx mediaplayer og medieklasse.


\subsection{Hvad har vi lært}
\subsubsection{Aslan}\label{HHVLA}
Dette projekt har bidraget meget til mit billede af, hvordan det er at arbejde inden for software/programmeringsfeltet. Jeg var i begyndelsen meget usikker på, hvordan man skulle arbejde som gruppe på ét projekt, da vi tidligere afleveringsopgaver ganske enkelt har delt de fire forskellige opgaver op imellem os. Jeg fandt dog hurtigt ud af, at systemet er det samme, og dog ikke. Man uddelegerer opgaver, men sparer også meget med hinanden, og kigger på tingene sammen. Man arbejder på at forbedre hinandens arbejde, så man i fællesskab kan komme frem til det bedst-mulige produkt. Derudover har dette forløb også bare været en god mulighed for at udvikle mine programmerings- og problemløsningskompetencer. Det har været fedt at kunne stå over for et problem, og have muligheden for at teste forskellige løsninger af døgnet rundt, frem for at skulle bekymre sig om andre fag. Jeg håber på flere forløb som dette i fremtiden, hvor vi alle er mere erfarne og kompetente programmører.  
\subsubsection{Yahya}
\subsubsection{Rasmus}

\subsubsection{Abinav}\label{AA}

